#!/usr/bin/env python

import argparse
import sys
import os
import json
import random

import pymongo

import dgeo
import dpy
import Flickr
import GeoMeanShift

m = pymongo.Connection()
mean_shifts = m.ltte.mean_shifts
photos = m.ltte.photos
clusters = m.ltte.clusters

def run_mean_shift(cell):
   initial_point = cell.center()
   lat = initial_point[1]
   lng = initial_point[0]
   print str(lat) + ", " + str(lng)
   ms = GeoMeanShift.GeoMeanShift([lat, lng], 0.005)
   start_id = mean_shifts.insert( { 'index': 0,  'first': True, 'location': [lat, lng] } )
   print start_id
   i = 1
   while not ms.done() and ms.step():
      lat = ms.current_mean()[0]
      lng = ms.current_mean()[1]
      mean_shifts.insert( { 'start': start_id, 'index': i,  'location': [lat, lng] } )
      print ms.current_mean()
      i = i + 1

def do_grid(args):
   bbox = json.load(file(args.region_of_interest_metadata))['bbox']
   grid = dgeo.GeoGrid(bbox['left'], bbox['right'], bbox['top'], bbox['bottom'], args.number_across)
   grid.foreach_cell(run_mean_shift)

def _list_meanshifts(args):
   bbox = json.load(file(args.region_of_interest_metadata))['bbox']
   left   = float(bbox['left'])
   right  = float(bbox['right'])
   top    = float(bbox['top'])
   bottom = float(bbox['bottom'])
   print "listing meanshifts in ROI " + args.region_of_interest_metadata
   results = clusters.find({'center': {'$within': {'$box': [[bottom, left], [top, right]]}}})
   for ms in results:
      print ms

def _clear_meanshifts(args):
   bbox = json.load(file(args.region_of_interest_metadata))['bbox']
   left   = float(bbox['left'])
   right  = float(bbox['right'])
   top    = float(bbox['top'])
   bottom = float(bbox['bottom'])
   print "clearing meanshifts in ROI " + args.region_of_interest_metadata
   clusters.remove({'center': {'$within': {'$box': [[bottom, left], [top, right]]}}})

def _plot_photos(args):
   #from PIL import Image, ImageDraw
   import numpy as np
   from skimage.io import imsave
   bbox = dgeo.LatLngBoundingBox(json.load(file(args.roi_path))['bbox'])
  
   print "Will color points by cluster: " + str(args.labels)
   colors = dict()
   if args.labels:
      for cluster in clusters.find():
         if bbox.contains(cluster['center']):
	    colors[cluster['_id']] = dpy.random_color3f()

   #plot = Image.new("L", (1024, int(1024 / bbox.aspect())))
   plot = np.zeros((1024, int(1024/bbox.aspect()), 3))

   print "plot photos in ROI " + args.roi_path
   count = 0
   for photo in photos.find({}, {'location':1, 'cluster':1}):
   #for photo in photos.find():

      #print photo['location']
      if bbox.contains(photo['location']):
         if count % 1000 == 0:
            print count
         # draw the point in the image
	 normal_pos = bbox.normalize(photo['location'])
	 x = plot.shape[0] * normal_pos[1]
	 y = plot.shape[1] * normal_pos[0]
	 if not args.labels:
            plot[x, y, 0] = plot[x, y, 0] + 1
            plot[x, y, 1] = plot[x, y, 1] + 1
            plot[x, y, 2] = plot[x, y, 2] + 1
	 else:
	    plot[x, y] = colors[photo['cluster']]

         count = count + 1
   if not args.labels:
      plot /= float(plot.max())
      plot = np.power(plot, 1.0 / 16.0)

   image_path = "data/plots/" + os.path.basename(args.roi_path) + str(count) + ".png"
   dpy.ensure_dir('data/plots')
   imsave(image_path, np.rot90(plot))
   print "Plotted " + str(count) + " photos to " + image_path

def _sklearn_meanshift(args):
   
   
   import numpy as np
   from sklearn.cluster import MeanShift, estimate_bandwidth
   bbox = dgeo.LatLngBoundingBox(json.load(file(args.roi_path))['bbox'])
   
   #plot = Image.new("L", (1024, int(1024 / bbox.aspect())))
   plot = np.zeros((1024, int(1024/bbox.aspect())))

   print "sklearn MeanShift of ROI " + args.roi_path
   
   point = photos.find_one()['location']
   points = None
   ids = []
   count = 0
   for photo in photos.find({}, {'location':1}):
      if bbox.contains(photo['location']):
	 if points == None:
	    points = np.array(photo['location'])
	 else:
	    points = np.vstack((points, photo['location']))
	 ids.append(photo['_id'])
         count = count + 1

   ms = MeanShift(bandwidth=0.003, bin_seeding=True)
   ms.fit(points)
   labels = ms.labels_
   cluster_centers = ms.cluster_centers_
   
   cluster_sizes = [ 0 for center in cluster_centers ]
   for label in labels:
     cluster_sizes[label] = cluster_sizes[label] + 1
   print cluster_sizes

   labels_unique = np.unique(labels)
   n_clusters_ = len(labels_unique)

   print "number of estimated clusters : %d" % n_clusters_
   print "number of labels : %d" % len(labels)
   label = 0
   cluster_ids = []
   for center in cluster_centers:
      
      latitude = center[0]
      longitude = center[1]
      _id = clusters.insert({'center':[latitude, longitude], 'label':label, 'count':cluster_sizes[label]})
      cluster_ids.append(_id)
      label = label + 1

   i = 0
   for _id in ids:
      #print "label " + str(labels[i])
      cluster_sizes[labels[i]] = cluster_sizes[labels[i]] + 1
      photos.update({'_id':_id}, {"$set": {'cluster':cluster_ids[labels[i]]}})
      i = i + 1
   print "update " + str(i) + "photo.cluster foreign keys"

def _random_photos(args):
  import shutil
  random_photos = []
  for i in range(0, args.N):
    random_photos.append(random_photo())
  dpy.ensure_dir(args.destination_directory)
  for image in random_photos:
    shutil.copy(image.jpg_path(), args.destination_directory + "/" + image.flickr_locator_string() + ".jpg")
    #print "cp " + image.jpg_path() + " " + args.destination_directory + "/" + image.flickr_locator_string() + ".jpg"

def random_photo():
  count = photos.count()
  index = random.randint(0, count)
  random_photo = photos.find().skip(index).limit(1).next()
  return Flickr.MirroredPhoto(random_photo)

parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(dest='command')

# geo_store_all
geo_store_all_parser = subparsers.add_parser('geo_store_all')
geo_store_all_parser.set_defaults(func=Flickr.geo_store_all)

# mean_shift_grid
mean_shift_grid = subparsers.add_parser('mean_shift_grid')
mean_shift_grid.add_argument('region_of_interest_metadata', type=str)
mean_shift_grid.add_argument('number_across', type=int)
mean_shift_grid.set_defaults(func=do_grid)

# clear_meanshifts
clear_meanshifts = subparsers.add_parser('clear_meanshifts')
clear_meanshifts.add_argument('region_of_interest_metadata', type=str)
clear_meanshifts.set_defaults(func=_clear_meanshifts)

# list_meanshifts
list_meanshifts = subparsers.add_parser('list_meanshifts')
list_meanshifts.add_argument('region_of_interest_metadata', type=str)
list_meanshifts.set_defaults(func=_list_meanshifts)

# sklearn_meanshift
sklearn_meanshift = subparsers.add_parser('sklearn_meanshift')
sklearn_meanshift.add_argument('roi_path', type=str)
sklearn_meanshift.set_defaults(func=_sklearn_meanshift)

# plot photos
sklearn_meanshift = subparsers.add_parser('plot_photos')
sklearn_meanshift.add_argument('roi_path', type=str)
sklearn_meanshift.add_argument('--labels', dest='labels', action='store_const',
                               const=True, default=False, help='color code points by cluster')
sklearn_meanshift.set_defaults(func=_plot_photos)

# random photos
random_photos = subparsers.add_parser('random')
random_photos.add_argument('N', type=int)
random_photos.add_argument('destination_directory', type=str)
random_photos.set_defaults(func=_random_photos)



args = parser.parse_args()
args.func(args)

